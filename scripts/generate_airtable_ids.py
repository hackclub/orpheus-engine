# orpheus-engine/scripts/generate_airtable_ids.py
import argparse
import os
import re
import sys
from pathlib import Path
from dotenv import load_dotenv
from pyairtable import Api
import logging
from typing import Any # Import Any for type hints

# --- Configuration ---
# Add project root to sys.path to import config models
PROJECT_ROOT = Path(__file__).parent.parent
sys.path.insert(0, str(PROJECT_ROOT))

# Now you can import from your project structure
try:
    from orpheus_engine.defs.airtable.config import AirtableServiceConfig
    # Import the *actual* config instance from definitions.py
    # This assumes definitions.py is importable and doesn't have side effects like starting Dagster services
    # Be cautious with direct imports from definitions files. A dedicated config file might be safer.
    # Alternative: Define config in a separate YAML/Python file and load it here AND in definitions.py
    from orpheus_engine.defs.airtable.definitions import airtable_config as resource_config
except ImportError as e:
    print(f"Error importing Airtable config from project: {e}")
    print("Ensure the script is run from the project root or PYTHONPATH is set correctly.")
    sys.exit(1)

# Where to write the generated Python file
DEFAULT_OUTPUT_FILE = PROJECT_ROOT / "orpheus_engine" / "defs" / "airtable" / "generated_ids.py"

# Set up basic logging
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
log = logging.getLogger(__name__)

# --- Helper Functions ---

def sanitize_name(name: str) -> str:
    """Converts a potentially non-pythonic name to a valid UPPER_SNAKE_CASE identifier."""
    # Replace non-alphanumeric characters with underscores
    s = re.sub(r'\W|^(?=\d)', '_', name)
    # Convert camelCase/PascalCase to snake_case (simplified)
    s = re.sub('([A-Z]+)', r'_\1', s).strip('_')
    # Handle multiple underscores
    s = re.sub(r'_+', '_', s)
    return s.upper()

# --- Main Generation Logic ---

def generate_ids(api: Api, config: AirtableServiceConfig, output_path: Path):
    """Fetches schemas and generates the Python constants file."""
    log.info(f"Starting Airtable ID generation. Output file: {output_path}")
    generated_code = [
        "# -*- coding: utf-8 -*-",
        "# Generated by scripts/generate_airtable_ids.py. DO NOT EDIT MANUALLY.",
        "# fmt: off", # Tell black/ruff to ignore this file
        "",
        "class AirtableIDs:",
        "    \"\"\"Container for generated Airtable Base, Table, and Field IDs.\"\"\"",
        "",
    ]
    has_content = False

    for base_key, base_config in config.bases.items():
        base_class_name = sanitize_name(base_key)
        log.info(f"Processing Base: {base_key} (ID: {base_config.base_id}) -> Class: {base_class_name}")
        generated_code.append(f"    class {base_class_name}:")
        generated_code.append(f"        \"\"\"IDs for Base '{base_key}' (ID: {base_config.base_id})\"\"\"")
        generated_code.append(f"        BASE_ID = \"{base_config.base_id}\"")
        generated_code.append("")
        has_content = True # Mark that we have at least one base

        try:
            # Get the base object from the API client
            base = api.base(base_config.base_id)
            # Fetch the entire base schema once
            base_schema = base.schema() # This makes one API call for the whole base
        except Exception as e:
            log.error(f"  Failed to fetch schema for base {base_key} (ID: {base_config.base_id}): {e}")
            generated_code.append(f"        # ERROR: Failed to fetch schema for base - {e}")
            generated_code.append("")
            continue # Skip to next base

        for table_key, table_config in base_config.tables.items():
            table_class_name = sanitize_name(table_key)
            log.info(f"  Processing Table: {table_key} (ID: {table_config.table_id}) -> Class: {table_class_name}")
            generated_code.append(f"        class {table_class_name}:")
            generated_code.append(f"            \"\"\"IDs for Table '{table_key}' (ID: {table_config.table_id})\"\"\"")
            generated_code.append(f"            TABLE_ID = \"{table_config.table_id}\"")
            generated_code.append("")

            try:
                # Access the specific table schema from the cached base schema
                # Use table ID for lookup to be robust against name changes
                table_schema = base_schema.table(table_config.table_id)
                if not table_schema or not table_schema.fields:
                     log.warning(f"    No fields found or invalid schema for table {table_key} (ID: {table_config.table_id}).")
                     generated_code.append("            # No fields found or schema invalid")
                     generated_code.append("")
                     continue # Skip to next table

                log.info(f"    Found {len(table_schema.fields)} fields.")
                for field in table_schema.fields:
                    # field objects here are FieldSchema instances from pyairtable.models.schema
                    field_name = getattr(field, 'name', None)
                    field_id = getattr(field, 'id', None)
                    if field_name and field_id:
                        const_name = sanitize_name(field_name)
                        # Add original name as comment for clarity
                        generated_code.append(f"            {const_name} = \"{field_id}\"  # Name: {field_name}")
                    else:
                        log.warning(f"    Skipping field with missing name or id in table {table_key}: {field}")

                generated_code.append("") # Newline after fields

            except KeyError:
                # Handle case where table_id from config doesn't exist in the fetched schema
                log.error(f"    Table ID '{table_config.table_id}' (for key '{table_key}') not found in schema for base '{base_key}'. Check configuration.")
                generated_code.append(f"            # ERROR: Table ID '{table_config.table_id}' not found in base schema.")
                generated_code.append("")
            except Exception as e:
                # Catch other potential errors during schema processing
                log.error(f"    Failed to process schema for table {table_key} (ID: {table_config.table_id}): {e}")
                generated_code.append(f"            # ERROR: Failed to process schema - {e}")
                generated_code.append("")

        generated_code.append("") # Newline after last table in base

    if not has_content:
        generated_code.append("    pass # No bases configured")

    generated_code.append("# fmt: on") # Re-enable formatting checks

    # Write the file
    output_path.parent.mkdir(parents=True, exist_ok=True)
    try:
        with open(output_path, "w", encoding="utf-8") as f:
            f.write("\n".join(generated_code))
        log.info(f"Successfully wrote generated IDs to {output_path}")
    except IOError as e:
        log.error(f"Failed to write output file {output_path}: {e}")
        sys.exit(1)

# --- Script Entry Point ---

if __name__ == "__main__":
    # Load environment variables (.env file in project root is common)
    dotenv_path = PROJECT_ROOT / ".env"
    if dotenv_path.exists():
        log.info(f"Loading environment variables from: {dotenv_path}")
        load_dotenv(dotenv_path=dotenv_path)
    else:
        log.warning(f".env file not found at {dotenv_path}. Relying on system environment variables.")

    parser = argparse.ArgumentParser(description="Generate Airtable Field ID constants from configured bases/tables.")
    parser.add_argument(
        "-o", "--output",
        type=Path,
        default=DEFAULT_OUTPUT_FILE,
        help=f"Output Python file path (default: {DEFAULT_OUTPUT_FILE})"
    )
    args = parser.parse_args()

    api_key = os.getenv("AIRTABLE_PERSONAL_ACCESS_TOKEN")
    if not api_key:
        log.error("AIRTABLE_PERSONAL_ACCESS_TOKEN environment variable not set.")
        sys.exit(1)

    try:
        airtable_api = Api(api_key)
        generate_ids(airtable_api, resource_config, args.output)
    except Exception as e:
        log.exception(f"An unexpected error occurred: {e}") # Log full traceback
        sys.exit(1) 